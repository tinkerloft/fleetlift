# Web UI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build an Inbox-first web dashboard (React SPA + Go API server) for reviewing diffs, approving/steering agents, and monitoring task progress — replacing CLI commands for human-in-the-loop interactions.

**Architecture:** New `cmd/server` binary serves a REST+SSE API at `/api/v1/` that wraps the existing `internal/client.Client` Temporal methods, plus embeds the pre-built React SPA as static files. No new persistence layer — Temporal is the source of truth. The frontend is in `web/` and is built by Vite before `go build` embeds it.

**Tech Stack:** Go 1.25, `github.com/go-chi/chi/v5`, `net/http`, `io/fs`, `embed`; React 18, TypeScript, Vite, react-router-dom v6, @tanstack/react-query v5, shadcn/ui + Tailwind CSS, react-diff-viewer-continued.

**Branch:** `feat/web-ui`

**Progress:**
- Phase A: Go API Backend — ✅ Complete (2026-02-19)
- Phase B: React Frontend — ✅ Complete (2026-02-19) — Note: uses Tailwind v4 + `@tailwindcss/vite` (shadcn v3.8 requires v4); `SteeringIteration.iteration_number` corrected from plan
- Phase C: Integration — ✅ Complete (2026-02-19)

---

## Phase A: Go API Backend ✅

### Task 1: Server skeleton + health endpoint

**Files:**
- Create: `cmd/server/main.go`
- Create: `internal/server/server.go`
- Create: `internal/server/server_test.go`

**Step 1: Add chi router dependency**

```bash
go get github.com/go-chi/chi/v5
go get github.com/go-chi/cors
```

**Step 2: Write the failing test**

`internal/server/server_test.go`:
```go
package server_test

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/tinkerloft/fleetlift/internal/server"
)

func TestHealthEndpoint(t *testing.T) {
	s := server.New(nil, nil)
	req := httptest.NewRequest(http.MethodGet, "/api/v1/health", nil)
	w := httptest.NewRecorder()
	s.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), `"status":"ok"`)
}
```

**Step 3: Run test to verify it fails**

```bash
go test ./internal/server/... -run TestHealthEndpoint -v
```
Expected: FAIL (package doesn't exist)

**Step 4: Create `internal/server/server.go`**

```go
// Package server provides the HTTP API server for the Fleetlift web UI.
package server

import (
	"encoding/json"
	"io/fs"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
)

// Server is the HTTP API server.
type Server struct {
	router   chi.Router
	client   TemporalClient
	staticFS fs.FS // pre-subbed FS rooted at index.html; nil in tests
}

// New creates a new Server. staticFS may be nil (disables static serving).
func New(client TemporalClient, staticFS fs.FS) *Server {
	s := &Server{client: client, staticFS: staticFS}
	s.router = s.buildRouter()
	return s
}

// ServeHTTP implements http.Handler.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.router.ServeHTTP(w, r)
}

func (s *Server) buildRouter() chi.Router {
	r := chi.NewRouter()
	r.Use(middleware.Logger)
	r.Use(middleware.Recoverer)
	r.Use(cors.Handler(cors.Options{
		AllowedOrigins: []string{"*"},
		AllowedMethods: []string{"GET", "POST", "OPTIONS"},
		AllowedHeaders: []string{"Accept", "Content-Type"},
	}))

	r.Get("/api/v1/health", s.handleHealth)

	// Task routes — signal/SSE handlers added in later tasks
	r.Get("/api/v1/tasks", s.handleListTasks)
	r.Get("/api/v1/tasks/inbox", s.handleGetInbox)
	r.Route("/api/v1/tasks/{id}", func(r chi.Router) {
		r.Get("/", s.handleGetTask)
		r.Get("/diff", s.handleGetDiff)
		r.Get("/logs", s.handleGetLogs)
		r.Get("/steering", s.handleGetSteering)
		r.Get("/progress", s.handleGetProgress)
		r.Get("/events", s.handleTaskEvents)
		r.Post("/approve", s.handleApprove)
		r.Post("/reject", s.handleReject)
		r.Post("/cancel", s.handleCancel)
		r.Post("/steer", s.handleSteer)
		r.Post("/continue", s.handleContinue)
	})

	// Static SPA (registered last so API routes take priority)
	if s.staticFS != nil {
		r.Handle("/*", s.buildStaticHandler())
	}

	return r
}

func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, http.StatusOK, map[string]string{"status": "ok"})
}

// Stub handlers implemented in later tasks.
func (s *Server) handleListTasks(w http.ResponseWriter, r *http.Request)  { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleGetInbox(w http.ResponseWriter, r *http.Request)   { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleGetTask(w http.ResponseWriter, r *http.Request)    { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleGetDiff(w http.ResponseWriter, r *http.Request)    { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleGetLogs(w http.ResponseWriter, r *http.Request)    { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleGetSteering(w http.ResponseWriter, r *http.Request){ http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleGetProgress(w http.ResponseWriter, r *http.Request){ http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleTaskEvents(w http.ResponseWriter, r *http.Request) { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleApprove(w http.ResponseWriter, r *http.Request)    { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleReject(w http.ResponseWriter, r *http.Request)     { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleCancel(w http.ResponseWriter, r *http.Request)     { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleSteer(w http.ResponseWriter, r *http.Request)      { http.Error(w, "not implemented", http.StatusNotImplemented) }
func (s *Server) handleContinue(w http.ResponseWriter, r *http.Request)   { http.Error(w, "not implemented", http.StatusNotImplemented) }

func writeJSON(w http.ResponseWriter, status int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(v)
}

func writeError(w http.ResponseWriter, status int, msg string) {
	writeJSON(w, status, map[string]string{"error": msg})
}
```

**Step 5: Create `cmd/server/main.go`** (embed wired in Task 16; for now just serves the API)

```go
// Package main is the Fleetlift API server entry point.
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	flclient "github.com/tinkerloft/fleetlift/internal/client"
	"github.com/tinkerloft/fleetlift/internal/server"
)

func main() {
	c, err := flclient.NewClient()
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to connect to Temporal: %v\n", err)
		os.Exit(1)
	}
	defer c.Close()

	addr := os.Getenv("FLEETLIFT_SERVER_ADDR")
	if addr == "" {
		addr = ":8080"
	}

	s := server.New(c, nil) // staticFS wired in Task 16
	log.Printf("Fleetlift server listening on %s", addr)
	if err := http.ListenAndServe(addr, s); err != nil {
		log.Fatalf("server error: %v", err)
	}
}
```

**Step 6: Run test to verify it passes**

```bash
go test ./internal/server/... -run TestHealthEndpoint -v
```
Expected: PASS

**Step 7: Build to verify compilation**

```bash
go build ./cmd/server/...
```

**Step 8: Commit**

```bash
git add cmd/server/main.go internal/server/server.go internal/server/server_test.go go.mod go.sum
git commit -m "feat(server): add cmd/server skeleton with health endpoint"
```

---

### Task 2: TemporalClient interface + mock

The server needs a testable interface so tests don't require a live Temporal connection. `*client.Client` already has all the required methods — this task just defines the interface it satisfies.

**Files:**
- Create: `internal/server/client_iface.go`
- Modify: `internal/server/server_test.go` (add mockClient)

**Step 1: Create `internal/server/client_iface.go`**

```go
package server

import (
	"context"

	flclient "github.com/tinkerloft/fleetlift/internal/client"
	"github.com/tinkerloft/fleetlift/internal/model"
)

// TemporalClient is the interface the server uses to interact with Temporal.
// *client.Client satisfies this interface.
type TemporalClient interface {
	ListWorkflows(ctx context.Context, statusFilter string, limit int) ([]flclient.WorkflowInfo, error)
	GetWorkflowStatus(ctx context.Context, workflowID string) (model.TaskStatus, error)
	GetWorkflowDiff(ctx context.Context, workflowID string) ([]model.DiffOutput, error)
	GetWorkflowVerifierLogs(ctx context.Context, workflowID string) ([]model.VerifierOutput, error)
	GetSteeringState(ctx context.Context, workflowID string) (*model.SteeringState, error)
	GetExecutionProgress(ctx context.Context, workflowID string) (*model.ExecutionProgress, error)
	ApproveWorkflow(ctx context.Context, workflowID string) error
	RejectWorkflow(ctx context.Context, workflowID string) error
	CancelWorkflow(ctx context.Context, workflowID string) error
	SteerWorkflow(ctx context.Context, workflowID, prompt string) error
	ContinueWorkflow(ctx context.Context, workflowID string, skipRemaining bool) error
	Close()
}
```

**Step 2: Add `mockClient` to `internal/server/server_test.go`** (below the imports, before the test functions)

```go
// mockClient is a test double for TemporalClient.
type mockClient struct {
	workflows     []flclient.WorkflowInfo
	status        model.TaskStatus
	diffs         []model.DiffOutput
	verifierLogs  []model.VerifierOutput
	steeringState *model.SteeringState
	progress      *model.ExecutionProgress
	err           error
}

func (m *mockClient) ListWorkflows(_ context.Context, _ string, _ int) ([]flclient.WorkflowInfo, error) {
	return m.workflows, m.err
}
func (m *mockClient) GetWorkflowStatus(_ context.Context, _ string) (model.TaskStatus, error) {
	return m.status, m.err
}
func (m *mockClient) GetWorkflowDiff(_ context.Context, _ string) ([]model.DiffOutput, error) {
	return m.diffs, m.err
}
func (m *mockClient) GetWorkflowVerifierLogs(_ context.Context, _ string) ([]model.VerifierOutput, error) {
	return m.verifierLogs, m.err
}
func (m *mockClient) GetSteeringState(_ context.Context, _ string) (*model.SteeringState, error) {
	return m.steeringState, m.err
}
func (m *mockClient) GetExecutionProgress(_ context.Context, _ string) (*model.ExecutionProgress, error) {
	return m.progress, m.err
}
func (m *mockClient) ApproveWorkflow(_ context.Context, _ string) error              { return m.err }
func (m *mockClient) RejectWorkflow(_ context.Context, _ string) error               { return m.err }
func (m *mockClient) CancelWorkflow(_ context.Context, _ string) error               { return m.err }
func (m *mockClient) SteerWorkflow(_ context.Context, _, _ string) error             { return m.err }
func (m *mockClient) ContinueWorkflow(_ context.Context, _ string, _ bool) error     { return m.err }
func (m *mockClient) Close()                                                         {}
```

Also add needed imports to `server_test.go`:
```go
import (
	"context"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	flclient "github.com/tinkerloft/fleetlift/internal/client"
	"github.com/tinkerloft/fleetlift/internal/model"
	"github.com/tinkerloft/fleetlift/internal/server"
)
```

**Step 3: Verify compilation**

```bash
go build ./internal/server/...
```

**Step 4: Commit**

```bash
git add internal/server/client_iface.go internal/server/server_test.go
git commit -m "feat(server): add TemporalClient interface and mock for tests"
```

---

### Task 3: Task list + inbox handlers

**Files:**
- Create: `internal/server/handlers_tasks.go`
- Modify: `internal/server/server.go` (remove stubs for these handlers)
- Modify: `internal/server/server_test.go` (add tests)

**Step 1: Write failing tests** (add to `server_test.go`)

```go
func TestListTasks(t *testing.T) {
	mc := &mockClient{
		workflows: []flclient.WorkflowInfo{
			{WorkflowID: "transform-abc-123", Status: "Running", StartTime: "2026-02-18 10:00:00"},
		},
		status: model.TaskStatusRunning,
	}
	s := server.New(mc, nil)
	req := httptest.NewRequest(http.MethodGet, "/api/v1/tasks", nil)
	w := httptest.NewRecorder()
	s.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	var resp map[string]any
	assert.NoError(t, json.Unmarshal(w.Body.Bytes(), &resp))
	tasks := resp["tasks"].([]any)
	assert.Len(t, tasks, 1)
}

func TestGetInbox_AwaitingApproval(t *testing.T) {
	mc := &mockClient{
		workflows: []flclient.WorkflowInfo{
			{WorkflowID: "transform-abc-123", Status: "Running", StartTime: "2026-02-18 10:00:00"},
		},
		status: model.TaskStatusAwaitingApproval,
	}
	s := server.New(mc, nil)
	req := httptest.NewRequest(http.MethodGet, "/api/v1/tasks/inbox", nil)
	w := httptest.NewRecorder()
	s.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	var resp map[string]any
	assert.NoError(t, json.Unmarshal(w.Body.Bytes(), &resp))
	items := resp["items"].([]any)
	assert.Len(t, items, 1)
	item := items[0].(map[string]any)
	assert.Equal(t, "awaiting_approval", item["inbox_type"])
}
```

Add `"encoding/json"` to the import block.

**Step 2: Run to verify failure**

```bash
go test ./internal/server/... -run "TestListTasks|TestGetInbox" -v
```
Expected: FAIL (returns 501)

**Step 3: Create `internal/server/handlers_tasks.go`**

```go
package server

import (
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/tinkerloft/fleetlift/internal/model"
)

// TaskSummary is the API representation of a workflow for list/inbox responses.
type TaskSummary struct {
	WorkflowID string           `json:"workflow_id"`
	Status     model.TaskStatus `json:"status"`
	StartTime  string           `json:"start_time"`
	InboxType  string           `json:"inbox_type,omitempty"`
	IsPaused   bool             `json:"is_paused,omitempty"`
}

func (s *Server) handleListTasks(w http.ResponseWriter, r *http.Request) {
	statusFilter := r.URL.Query().Get("status")
	workflows, err := s.client.ListWorkflows(r.Context(), statusFilter, 100)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}

	tasks := make([]TaskSummary, 0, len(workflows))
	for _, wf := range workflows {
		status, _ := s.client.GetWorkflowStatus(r.Context(), wf.WorkflowID)
		tasks = append(tasks, TaskSummary{
			WorkflowID: wf.WorkflowID,
			Status:     status,
			StartTime:  wf.StartTime,
		})
	}
	writeJSON(w, http.StatusOK, map[string]any{"tasks": tasks})
}

func (s *Server) handleGetInbox(w http.ResponseWriter, r *http.Request) {
	running, err := s.client.ListWorkflows(r.Context(), "Running", 100)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}

	var items []TaskSummary
	for _, wf := range running {
		status, err := s.client.GetWorkflowStatus(r.Context(), wf.WorkflowID)
		if err != nil {
			continue
		}

		inboxType := ""
		isPaused := false

		switch status {
		case model.TaskStatusAwaitingApproval:
			inboxType = "awaiting_approval"
		case model.TaskStatusRunning:
			progress, err := s.client.GetExecutionProgress(r.Context(), wf.WorkflowID)
			if err == nil && progress != nil && progress.IsPaused {
				inboxType = "paused"
				isPaused = true
			}
		}

		if inboxType != "" {
			items = append(items, TaskSummary{
				WorkflowID: wf.WorkflowID,
				Status:     status,
				StartTime:  wf.StartTime,
				InboxType:  inboxType,
				IsPaused:   isPaused,
			})
		}
	}

	// Include recently completed tasks (last 24h) for passive review.
	completed, _ := s.client.ListWorkflows(r.Context(), "Completed", 20)
	for _, wf := range completed {
		t, err := time.Parse("2006-01-02 15:04:05", wf.StartTime)
		if err != nil || time.Since(t) > 24*time.Hour {
			continue
		}
		items = append(items, TaskSummary{
			WorkflowID: wf.WorkflowID,
			Status:     model.TaskStatusCompleted,
			StartTime:  wf.StartTime,
			InboxType:  "completed_review",
		})
	}

	if items == nil {
		items = []TaskSummary{}
	}
	writeJSON(w, http.StatusOK, map[string]any{"items": items})
}

func (s *Server) handleGetTask(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	status, err := s.client.GetWorkflowStatus(r.Context(), id)
	if err != nil {
		writeError(w, http.StatusNotFound, "workflow not found")
		return
	}
	writeJSON(w, http.StatusOK, TaskSummary{WorkflowID: id, Status: status})
}

func (s *Server) handleGetDiff(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	diffs, err := s.client.GetWorkflowDiff(r.Context(), id)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, map[string]any{"diffs": diffs})
}

func (s *Server) handleGetLogs(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	logs, err := s.client.GetWorkflowVerifierLogs(r.Context(), id)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, map[string]any{"logs": logs})
}

func (s *Server) handleGetSteering(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	state, err := s.client.GetSteeringState(r.Context(), id)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, state)
}

func (s *Server) handleGetProgress(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	progress, err := s.client.GetExecutionProgress(r.Context(), id)
	if err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, progress)
}
```

**Step 4: Remove the matching stubs from `server.go`**

Delete the stub definitions for `handleListTasks`, `handleGetInbox`, `handleGetTask`, `handleGetDiff`, `handleGetLogs`, `handleGetSteering`, `handleGetProgress` from `server.go`. Keep the stubs for the signal and SSE handlers.

**Step 5: Run tests**

```bash
go test ./internal/server/... -v
```
Expected: all PASS

**Step 6: Commit**

```bash
git add internal/server/handlers_tasks.go internal/server/server.go internal/server/server_test.go
git commit -m "feat(server): add task list, inbox, and query handlers"
```

---

### Task 4: Signal handlers

**Files:**
- Create: `internal/server/handlers_signals.go`
- Modify: `internal/server/server.go` (remove matching stubs)
- Modify: `internal/server/server_test.go` (add tests)

**Step 1: Write failing tests**

```go
func TestApproveWorkflow(t *testing.T) {
	s := server.New(&mockClient{}, nil)
	req := httptest.NewRequest(http.MethodPost, "/api/v1/tasks/transform-abc-123/approve", nil)
	w := httptest.NewRecorder()
	s.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code)
}

func TestSteerWorkflow(t *testing.T) {
	s := server.New(&mockClient{}, nil)
	body := strings.NewReader(`{"prompt":"use slog instead"}`)
	req := httptest.NewRequest(http.MethodPost, "/api/v1/tasks/transform-abc-123/steer", body)
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code)
}

func TestSteerWorkflow_MissingPrompt(t *testing.T) {
	s := server.New(&mockClient{}, nil)
	body := strings.NewReader(`{}`)
	req := httptest.NewRequest(http.MethodPost, "/api/v1/tasks/transform-abc-123/steer", body)
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	s.ServeHTTP(w, req)
	assert.Equal(t, http.StatusBadRequest, w.Code)
}
```

Add `"strings"` to imports.

**Step 2: Run to verify failure**

```bash
go test ./internal/server/... -run "TestApproveWorkflow|TestSteerWorkflow" -v
```
Expected: FAIL (returns 501)

**Step 3: Create `internal/server/handlers_signals.go`**

```go
package server

import (
	"encoding/json"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func (s *Server) handleApprove(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if err := s.client.ApproveWorkflow(r.Context(), id); err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, map[string]string{"status": "approved"})
}

func (s *Server) handleReject(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if err := s.client.RejectWorkflow(r.Context(), id); err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, map[string]string{"status": "rejected"})
}

func (s *Server) handleCancel(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if err := s.client.CancelWorkflow(r.Context(), id); err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, map[string]string{"status": "cancelled"})
}

type steerRequest struct {
	Prompt string `json:"prompt"`
}

func (s *Server) handleSteer(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	var req steerRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeError(w, http.StatusBadRequest, "invalid request body")
		return
	}
	if req.Prompt == "" {
		writeError(w, http.StatusBadRequest, "prompt is required")
		return
	}
	if err := s.client.SteerWorkflow(r.Context(), id, req.Prompt); err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, map[string]string{"status": "steering"})
}

type continueRequest struct {
	SkipRemaining bool `json:"skip_remaining"`
}

func (s *Server) handleContinue(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	var req continueRequest
	_ = json.NewDecoder(r.Body).Decode(&req)
	if err := s.client.ContinueWorkflow(r.Context(), id, req.SkipRemaining); err != nil {
		writeError(w, http.StatusInternalServerError, err.Error())
		return
	}
	writeJSON(w, http.StatusOK, map[string]string{"status": "continued"})
}
```

**Step 4: Remove the matching stubs from `server.go`**

Delete `handleApprove`, `handleReject`, `handleCancel`, `handleSteer`, `handleContinue` stubs.

**Step 5: Run tests**

```bash
go test ./internal/server/... -v
```
Expected: all PASS

**Step 6: Commit**

```bash
git add internal/server/handlers_signals.go internal/server/server.go internal/server/server_test.go
git commit -m "feat(server): add signal handlers (approve, reject, cancel, steer, continue)"
```

---

### Task 5: SSE live updates handler

**Files:**
- Create: `internal/server/sse.go`
- Modify: `internal/server/server.go` (remove stub)
- Modify: `internal/server/server_test.go` (add test)

**Step 1: Write failing test**

```go
func TestSSEEndpoint(t *testing.T) {
	mc := &mockClient{status: model.TaskStatusRunning}
	s := server.New(mc, nil)

	ctx, cancel := context.WithTimeout(context.Background(), 150*time.Millisecond)
	defer cancel()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/tasks/transform-abc-123/events", nil).WithContext(ctx)
	w := httptest.NewRecorder()
	s.ServeHTTP(w, req)

	assert.Equal(t, "text/event-stream", w.Header().Get("Content-Type"))
	assert.Contains(t, w.Body.String(), "event: status")
}
```

Add `"time"` and `"context"` to imports.

**Step 2: Run to verify failure**

```bash
go test ./internal/server/... -run TestSSEEndpoint -v
```
Expected: FAIL (returns 501)

**Step 3: Create `internal/server/sse.go`**

```go
package server

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
)

func (s *Server) handleTaskEvents(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	flusher, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "streaming not supported", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	// Send initial status immediately.
	s.pushStatusEvent(w, flusher, r, id)

	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()
	for {
		select {
		case <-r.Context().Done():
			return
		case <-ticker.C:
			s.pushStatusEvent(w, flusher, r, id)
		}
	}
}

func (s *Server) pushStatusEvent(w http.ResponseWriter, flusher http.Flusher, r *http.Request, id string) {
	status, err := s.client.GetWorkflowStatus(r.Context(), id)
	if err != nil {
		fmt.Fprintf(w, "event: error\ndata: %s\n\n", err.Error())
		flusher.Flush()
		return
	}
	data, _ := json.Marshal(map[string]any{"status": status})
	fmt.Fprintf(w, "event: status\ndata: %s\n\n", data)
	flusher.Flush()
}
```

**Step 4: Remove `handleTaskEvents` stub from `server.go`**

**Step 5: Run tests**

```bash
go test ./internal/server/... -v
```
Expected: all PASS

**Step 6: Commit**

```bash
git add internal/server/sse.go internal/server/server.go internal/server/server_test.go
git commit -m "feat(server): add SSE live status updates handler"
```

---

## Phase B: React Frontend ✅

### Task 6: Vite + React scaffold

**Files:**
- Create: `web/` (Vite project)

**Step 1: Scaffold at repo root**

```bash
npm create vite@latest web -- --template react-ts
```

**Step 2: Install dependencies**

```bash
cd web
npm install
npm install react-router-dom @tanstack/react-query react-diff-viewer-continued
npm install -D tailwindcss postcss autoprefixer @types/node
npx tailwindcss init -p
```

**Step 3: Install shadcn/ui**

```bash
npx shadcn@latest init
# Prompts: TypeScript=yes, Default style, slate, src/lib/utils.ts, no RSC
npx shadcn@latest add button badge tabs card separator
```

**Step 4: Configure Tailwind** — replace `web/tailwind.config.js`:

```js
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{ts,tsx}"],
  theme: { extend: {} },
  plugins: [],
}
```

Replace top of `web/src/index.css` with:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

**Step 5: Configure Vite** — replace `web/vite.config.ts`:

```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: { alias: { '@': path.resolve(__dirname, './src') } },
  server: { proxy: { '/api': 'http://localhost:8080' } },
  build: { outDir: 'dist' },
})
```

**Step 6: Add `web/tsconfig.json` path alias** — in `compilerOptions` add:

```json
"baseUrl": ".",
"paths": { "@/*": ["./src/*"] }
```

**Step 7: Verify dev server starts**

```bash
cd web && npm run dev
```
Expected: Vite dev server at http://localhost:5173

**Step 8: Add `web/dist/.gitkeep`** (needed so Go embed doesn't fail when dist doesn't exist yet in CI)

```bash
mkdir -p web/dist && touch web/dist/.gitkeep
```

**Step 9: Commit**

```bash
cd ..
git add web/
git commit -m "feat(web): scaffold Vite + React + TypeScript + shadcn/ui frontend"
```

---

### Task 7: TypeScript API types + client

**Files:**
- Create: `web/src/api/types.ts`
- Create: `web/src/api/client.ts`

**Step 1: Create `web/src/api/types.ts`**

Check `internal/model/task.go` for exact JSON field names before writing. Mirror:

```ts
export type TaskStatus =
  | 'pending' | 'provisioning' | 'cloning' | 'running'
  | 'awaiting_approval' | 'creating_prs' | 'completed' | 'failed' | 'cancelled'

export type InboxType = 'awaiting_approval' | 'paused' | 'steering_requested' | 'completed_review'

export interface TaskSummary {
  workflow_id: string
  status: TaskStatus
  start_time: string
  inbox_type?: InboxType
  is_paused?: boolean
}

export interface FileDiff {
  path: string
  status: 'modified' | 'added' | 'deleted'
  additions: number
  deletions: number
  diff: string
}

export interface DiffOutput {
  repository: string
  files: FileDiff[]
  summary: string
  total_lines: number
  truncated: boolean
}

export interface VerifierOutput {
  verifier: string
  exit_code: number
  stdout: string
  stderr: string
  success: boolean
}

export interface SteeringIteration {
  prompt: string    // check model.SteeringIteration JSON tags in internal/model/task.go
  iteration: number
}

export interface SteeringState {
  current_iteration: number
  max_iterations: number
  history: SteeringIteration[]
}

export interface ExecutionProgress {
  total_groups: number
  completed_groups: number
  failed_groups: number
  failure_percent: number
  is_paused: boolean
  paused_reason?: string
  failed_group_names?: string[]
}
```

**Step 2: Create `web/src/api/client.ts`**

```ts
import type {
  TaskSummary, DiffOutput, VerifierOutput,
  SteeringState, ExecutionProgress,
} from './types'

const BASE = '/api/v1'

async function get<T>(path: string): Promise<T> {
  const res = await fetch(`${BASE}${path}`)
  if (!res.ok) {
    const err = await res.json().catch(() => ({ error: res.statusText }))
    throw new Error(err.error ?? res.statusText)
  }
  return res.json()
}

async function post<T>(path: string, body?: unknown): Promise<T> {
  const res = await fetch(`${BASE}${path}`, {
    method: 'POST',
    headers: body ? { 'Content-Type': 'application/json' } : undefined,
    body: body ? JSON.stringify(body) : undefined,
  })
  if (!res.ok) {
    const err = await res.json().catch(() => ({ error: res.statusText }))
    throw new Error(err.error ?? res.statusText)
  }
  return res.json()
}

export const api = {
  listTasks: (status?: string) =>
    get<{ tasks: TaskSummary[] }>(`/tasks${status ? `?status=${status}` : ''}`),
  getInbox: () => get<{ items: TaskSummary[] }>('/tasks/inbox'),
  getTask:  (id: string) => get<TaskSummary>(`/tasks/${id}`),
  getDiff:  (id: string) => get<{ diffs: DiffOutput[] }>(`/tasks/${id}/diff`),
  getLogs:  (id: string) => get<{ logs: VerifierOutput[] }>(`/tasks/${id}/logs`),
  getSteering: (id: string) => get<SteeringState>(`/tasks/${id}/steering`),
  getProgress: (id: string) => get<ExecutionProgress>(`/tasks/${id}/progress`),

  approve: (id: string) => post<{ status: string }>(`/tasks/${id}/approve`),
  reject:  (id: string) => post<{ status: string }>(`/tasks/${id}/reject`),
  cancel:  (id: string) => post<{ status: string }>(`/tasks/${id}/cancel`),
  steer:   (id: string, prompt: string) =>
    post<{ status: string }>(`/tasks/${id}/steer`, { prompt }),
  continue: (id: string, skipRemaining: boolean) =>
    post<{ status: string }>(`/tasks/${id}/continue`, { skip_remaining: skipRemaining }),
}

/** Subscribe to live status updates via SSE. Returns an unsubscribe function. */
export function subscribeToTask(
  id: string,
  onStatus: (status: string) => void,
  onError?: (e: Event) => void,
): () => void {
  const es = new EventSource(`${BASE}/tasks/${id}/events`)
  es.addEventListener('status', (e) => {
    const data = JSON.parse((e as MessageEvent).data)
    onStatus(data.status)
  })
  if (onError) es.onerror = onError
  return () => es.close()
}
```

**Step 3: Verify TypeScript compiles**

```bash
cd web && npx tsc --noEmit
```

**Step 4: Commit**

```bash
cd ..
git add web/src/api/
git commit -m "feat(web): add TypeScript API types and client"
```

---

### Task 8: App shell + routing

**Files:**
- Modify: `web/src/main.tsx`
- Modify: `web/src/App.tsx`
- Create: `web/src/components/Layout.tsx`
- Create stub pages: `web/src/pages/Inbox.tsx`, `web/src/pages/TaskList.tsx`, `web/src/pages/TaskDetail.tsx`

**Step 1: Update `web/src/main.tsx`**

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import App from './App.tsx'
import './index.css'

const queryClient = new QueryClient({
  defaultOptions: { queries: { staleTime: 10_000, retry: 1 } },
})

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </React.StrictMode>,
)
```

**Step 2: Create `web/src/components/Layout.tsx`**

```tsx
import { Link, useLocation } from 'react-router-dom'

export function Layout({ children }: { children: React.ReactNode }) {
  const { pathname } = useLocation()
  const nav = [
    { href: '/', label: 'Inbox' },
    { href: '/tasks', label: 'All Tasks' },
  ]
  return (
    <div className="min-h-screen bg-background">
      <header className="border-b px-6 py-3 flex items-center gap-6">
        <span className="font-semibold text-lg">Fleetlift</span>
        <nav className="flex gap-4 text-sm">
          {nav.map(({ href, label }) => (
            <Link
              key={href}
              to={href}
              className={
                pathname === href
                  ? 'text-foreground font-medium'
                  : 'text-muted-foreground hover:text-foreground'
              }
            >
              {label}
            </Link>
          ))}
        </nav>
      </header>
      <main className="px-6 py-6">{children}</main>
    </div>
  )
}
```

**Step 3: Update `web/src/App.tsx`**

```tsx
import { Routes, Route } from 'react-router-dom'
import { Layout } from './components/Layout'
import { InboxPage } from './pages/Inbox'
import { TaskListPage } from './pages/TaskList'
import { TaskDetailPage } from './pages/TaskDetail'

export default function App() {
  return (
    <Layout>
      <Routes>
        <Route path="/" element={<InboxPage />} />
        <Route path="/tasks" element={<TaskListPage />} />
        <Route path="/tasks/:id" element={<TaskDetailPage />} />
      </Routes>
    </Layout>
  )
}
```

**Step 4: Create stub pages**

`web/src/pages/Inbox.tsx`: `export function InboxPage() { return <div>Inbox</div> }`
`web/src/pages/TaskList.tsx`: `export function TaskListPage() { return <div>All Tasks</div> }`
`web/src/pages/TaskDetail.tsx`: `export function TaskDetailPage() { return <div>Task Detail</div> }`

**Step 5: Verify build**

```bash
cd web && npm run build
```

**Step 6: Commit**

```bash
cd ..
git add web/src/
git commit -m "feat(web): add app shell, routing, and layout"
```

---

### Task 9: Inbox page

**Files:**
- Modify: `web/src/pages/Inbox.tsx`

**Step 1: Implement `Inbox.tsx`**

```tsx
import { useQuery } from '@tanstack/react-query'
import { Link } from 'react-router-dom'
import { api } from '@/api/client'
import type { TaskSummary, InboxType } from '@/api/types'
import { Badge } from '@/components/ui/badge'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'

const INBOX_CONFIG: Record<InboxType, { label: string; variant: 'default' | 'secondary' | 'destructive' | 'outline' }> = {
  awaiting_approval:  { label: 'Needs Approval', variant: 'default' },
  paused:             { label: 'Paused',          variant: 'destructive' },
  steering_requested: { label: 'Needs Steering',  variant: 'destructive' },
  completed_review:   { label: 'Review',          variant: 'secondary' },
}

function InboxItem({ item }: { item: TaskSummary }) {
  const config = item.inbox_type
    ? (INBOX_CONFIG[item.inbox_type] ?? { label: item.inbox_type, variant: 'outline' as const })
    : { label: '', variant: 'outline' as const }

  return (
    <Link to={`/tasks/${item.workflow_id}`}>
      <Card className="hover:border-foreground/30 transition-colors cursor-pointer">
        <CardContent className="pt-4 pb-4 flex items-center justify-between">
          <div>
            <p className="font-mono text-sm font-medium">{item.workflow_id}</p>
            <p className="text-xs text-muted-foreground mt-1">{item.start_time}</p>
          </div>
          <Badge variant={config.variant}>{config.label}</Badge>
        </CardContent>
      </Card>
    </Link>
  )
}

export function InboxPage() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['inbox'],
    queryFn: () => api.getInbox(),
    refetchInterval: 5000,
  })

  if (isLoading) return <p className="text-sm text-muted-foreground">Loading...</p>
  if (error)     return <p className="text-sm text-destructive">Error: {String(error)}</p>

  const items = data?.items ?? []

  return (
    <div className="max-w-2xl">
      <Card>
        <CardHeader>
          <CardTitle className="text-base">Inbox</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2">
          {items.length === 0 ? (
            <p className="text-sm text-muted-foreground py-4 text-center">No pending actions</p>
          ) : (
            items.map((item) => <InboxItem key={item.workflow_id} item={item} />)
          )}
        </CardContent>
      </Card>
    </div>
  )
}
```

**Step 2: Verify build**

```bash
cd web && npm run build
```

**Step 3: Commit**

```bash
cd ..
git add web/src/pages/Inbox.tsx
git commit -m "feat(web): implement Inbox page with live polling"
```

---

### Task 10: Task list page

**Files:**
- Modify: `web/src/pages/TaskList.tsx`

**Step 1: Implement `TaskList.tsx`**

```tsx
import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
import { Link } from 'react-router-dom'
import { api } from '@/api/client'
import { Badge } from '@/components/ui/badge'

const STATUS_OPTIONS = ['', 'Running', 'Completed', 'Failed'] as const
const STATUS_LABELS: Record<string, string> = { '': 'All', Running: 'Running', Completed: 'Completed', Failed: 'Failed' }
const STATUS_VARIANT: Record<string, 'default' | 'secondary' | 'destructive' | 'outline'> = {
  running: 'default', awaiting_approval: 'default',
  completed: 'secondary', failed: 'destructive', cancelled: 'outline',
}

export function TaskListPage() {
  const [filter, setFilter] = useState('')
  const { data, isLoading } = useQuery({
    queryKey: ['tasks', filter],
    queryFn: () => api.listTasks(filter || undefined),
    refetchInterval: 10_000,
  })

  return (
    <div className="max-w-3xl">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-lg font-semibold">All Tasks</h1>
        <div className="flex gap-2">
          {STATUS_OPTIONS.map((opt) => (
            <button
              key={opt}
              onClick={() => setFilter(opt)}
              className={`px-3 py-1 rounded text-sm border transition-colors ${
                filter === opt ? 'bg-foreground text-background' : 'hover:bg-muted'
              }`}
            >
              {STATUS_LABELS[opt]}
            </button>
          ))}
        </div>
      </div>

      {isLoading ? (
        <p className="text-sm text-muted-foreground">Loading...</p>
      ) : (
        <div className="space-y-2">
          {(data?.tasks ?? []).map((task) => (
            <Link
              key={task.workflow_id}
              to={`/tasks/${task.workflow_id}`}
              className="flex items-center justify-between border rounded-lg px-4 py-3 hover:border-foreground/30 transition-colors"
            >
              <div>
                <p className="font-mono text-sm font-medium">{task.workflow_id}</p>
                <p className="text-xs text-muted-foreground">{task.start_time}</p>
              </div>
              <Badge variant={STATUS_VARIANT[task.status] ?? 'outline'}>{task.status}</Badge>
            </Link>
          ))}
          {data?.tasks?.length === 0 && (
            <p className="text-sm text-muted-foreground text-center py-8">No tasks found</p>
          )}
        </div>
      )}
    </div>
  )
}
```

**Step 2: Verify build, commit**

```bash
cd web && npm run build && cd ..
git add web/src/pages/TaskList.tsx
git commit -m "feat(web): implement Task List page with status filter"
```

---

### Task 11: Task Detail page + component stubs

**Files:**
- Modify: `web/src/pages/TaskDetail.tsx`
- Create stubs: `web/src/components/DiffViewer.tsx`, `web/src/components/VerifierLogs.tsx`, `web/src/components/SteeringPanel.tsx`, `web/src/components/GroupProgress.tsx`

**Step 1: Create stub components** (each returns a loading placeholder)

`web/src/components/DiffViewer.tsx`:
```tsx
export function DiffViewer({ workflowId }: { workflowId: string }) {
  return <div className="text-sm text-muted-foreground">DiffViewer: {workflowId}</div>
}
```
Same pattern for `VerifierLogs`, `SteeringPanel`, `GroupProgress`.

**Step 2: Implement `TaskDetail.tsx`**

```tsx
import { useEffect, useState } from 'react'
import { useParams } from 'react-router-dom'
import { useQuery } from '@tanstack/react-query'
import { api, subscribeToTask } from '@/api/client'
import type { TaskStatus } from '@/api/types'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Badge } from '@/components/ui/badge'
import { DiffViewer } from '@/components/DiffViewer'
import { VerifierLogs } from '@/components/VerifierLogs'
import { SteeringPanel } from '@/components/SteeringPanel'
import { GroupProgress } from '@/components/GroupProgress'

const STATUS_VARIANT: Record<string, 'default' | 'secondary' | 'destructive' | 'outline'> = {
  running: 'default', awaiting_approval: 'default',
  completed: 'secondary', failed: 'destructive',
}

export function TaskDetailPage() {
  const { id } = useParams<{ id: string }>()
  const [liveStatus, setLiveStatus] = useState<TaskStatus | null>(null)

  const { data: task } = useQuery({
    queryKey: ['task', id],
    queryFn: () => api.getTask(id!),
    enabled: !!id,
  })

  useEffect(() => {
    if (!id) return
    return subscribeToTask(id, (s) => setLiveStatus(s as TaskStatus))
  }, [id])

  const status = liveStatus ?? task?.status
  const isAwaitingApproval = status === 'awaiting_approval'

  return (
    <div className="max-w-5xl">
      <div className="flex items-center gap-3 mb-6">
        <h1 className="text-lg font-semibold font-mono">{id}</h1>
        {status && (
          <Badge variant={STATUS_VARIANT[status] ?? 'outline'}>{status}</Badge>
        )}
      </div>

      <Tabs defaultValue="diff">
        <TabsList>
          <TabsTrigger value="diff">Diff</TabsTrigger>
          <TabsTrigger value="logs">Verifier Logs</TabsTrigger>
          <TabsTrigger value="progress">Group Progress</TabsTrigger>
          {isAwaitingApproval && (
            <TabsTrigger value="steer">Approve / Steer</TabsTrigger>
          )}
        </TabsList>
        <TabsContent value="diff" className="mt-4">
          <DiffViewer workflowId={id!} />
        </TabsContent>
        <TabsContent value="logs" className="mt-4">
          <VerifierLogs workflowId={id!} />
        </TabsContent>
        <TabsContent value="progress" className="mt-4">
          <GroupProgress workflowId={id!} />
        </TabsContent>
        {isAwaitingApproval && (
          <TabsContent value="steer" className="mt-4">
            <SteeringPanel workflowId={id!} />
          </TabsContent>
        )}
      </Tabs>
    </div>
  )
}
```

**Step 3: Verify build, commit**

```bash
cd web && npm run build && cd ..
git add web/src/pages/TaskDetail.tsx web/src/components/
git commit -m "feat(web): add Task Detail page with tabs and SSE live status"
```

---

### Task 12: DiffViewer component

**Files:**
- Modify: `web/src/components/DiffViewer.tsx`

**Step 1: Implement `DiffViewer.tsx`**

The diff strings from Go are unified diff format. We split them into old/new content for react-diff-viewer-continued.

```tsx
import { useQuery } from '@tanstack/react-query'
import ReactDiffViewer, { DiffMethod } from 'react-diff-viewer-continued'
import { api } from '@/api/client'
import type { DiffOutput, FileDiff } from '@/api/types'

function parseOldContent(diff: string): string {
  return diff.split('\n')
    .filter((l) => !l.startsWith('+') || l.startsWith('+++'))
    .map((l) => l.startsWith('-') ? l.slice(1) : l.startsWith('@@') ? '' : l)
    .join('\n')
}

function parseNewContent(diff: string): string {
  return diff.split('\n')
    .filter((l) => !l.startsWith('-') || l.startsWith('---'))
    .map((l) => l.startsWith('+') ? l.slice(1) : l.startsWith('@@') ? '' : l)
    .join('\n')
}

function FileSection({ file }: { file: FileDiff }) {
  return (
    <details className="mb-2 border rounded overflow-hidden" open>
      <summary className="px-3 py-2 text-sm font-mono cursor-pointer bg-muted/30 hover:bg-muted/50 flex items-center gap-3">
        <span className="flex-1">{file.path}</span>
        <span className="text-xs text-green-600">+{file.additions}</span>
        <span className="text-xs text-red-600">-{file.deletions}</span>
      </summary>
      <div className="text-xs overflow-auto">
        <ReactDiffViewer
          oldValue={parseOldContent(file.diff)}
          newValue={parseNewContent(file.diff)}
          splitView={false}
          compareMethod={DiffMethod.LINES}
        />
      </div>
    </details>
  )
}

function RepoSection({ diff }: { diff: DiffOutput }) {
  return (
    <div className="mb-6">
      <div className="flex items-center gap-2 mb-2">
        <h3 className="font-mono text-sm font-medium">{diff.repository}</h3>
        <span className="text-xs text-muted-foreground">
          {diff.files.length} file{diff.files.length !== 1 ? 's' : ''} · {diff.total_lines} lines
        </span>
        {diff.truncated && <span className="text-xs text-yellow-600">(truncated)</span>}
      </div>
      {diff.files.map((file) => <FileSection key={file.path} file={file} />)}
    </div>
  )
}

export function DiffViewer({ workflowId }: { workflowId: string }) {
  const { data, isLoading, error } = useQuery({
    queryKey: ['diff', workflowId],
    queryFn: () => api.getDiff(workflowId),
    refetchInterval: 15_000,
  })

  if (isLoading) return <p className="text-sm text-muted-foreground">Loading diffs...</p>
  if (error)     return <p className="text-sm text-destructive">Failed to load diffs</p>
  if (!data?.diffs?.length) return <p className="text-sm text-muted-foreground">No changes yet.</p>

  return <div>{data.diffs.map((d) => <RepoSection key={d.repository} diff={d} />)}</div>
}
```

**Step 2: Verify build, commit**

```bash
cd web && npm run build && cd ..
git add web/src/components/DiffViewer.tsx
git commit -m "feat(web): implement DiffViewer with syntax-highlighted unified diffs"
```

---

### Task 13: SteeringPanel component

**Files:**
- Modify: `web/src/components/SteeringPanel.tsx`

**Step 1: Implement `SteeringPanel.tsx`**

```tsx
import { useState } from 'react'
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { api } from '@/api/client'
import { Button } from '@/components/ui/button'
import { Separator } from '@/components/ui/separator'

export function SteeringPanel({ workflowId }: { workflowId: string }) {
  const [prompt, setPrompt] = useState('')
  const qc = useQueryClient()

  const { data: steering } = useQuery({
    queryKey: ['steering', workflowId],
    queryFn: () => api.getSteering(workflowId),
  })

  const approveMutation = useMutation({
    mutationFn: () => api.approve(workflowId),
    onSuccess: () => qc.invalidateQueries({ queryKey: ['task', workflowId] }),
  })
  const rejectMutation = useMutation({
    mutationFn: () => api.reject(workflowId),
    onSuccess: () => qc.invalidateQueries({ queryKey: ['task', workflowId] }),
  })
  const steerMutation = useMutation({
    mutationFn: () => api.steer(workflowId, prompt),
    onSuccess: () => {
      setPrompt('')
      qc.invalidateQueries({ queryKey: ['steering', workflowId] })
    },
  })

  const busy = approveMutation.isPending || rejectMutation.isPending || steerMutation.isPending

  return (
    <div className="space-y-6 max-w-2xl">
      {/* Approve / Reject */}
      <div>
        <h3 className="text-sm font-medium mb-3">Decision</h3>
        <div className="flex gap-3">
          <Button onClick={() => approveMutation.mutate()} disabled={busy}
            className="bg-green-600 hover:bg-green-700">
            Approve &amp; Create PRs
          </Button>
          <Button variant="outline" onClick={() => rejectMutation.mutate()} disabled={busy}>
            Reject
          </Button>
        </div>
        {approveMutation.isSuccess && (
          <p className="text-sm text-green-600 mt-2">Approved — PRs being created...</p>
        )}
        {rejectMutation.isSuccess && (
          <p className="text-sm text-muted-foreground mt-2">Changes rejected.</p>
        )}
      </div>

      <Separator />

      {/* Steering */}
      <div>
        <h3 className="text-sm font-medium mb-1">
          Steer the agent
          {steering && (
            <span className="text-muted-foreground font-normal ml-2 text-xs">
              ({steering.current_iteration}/{steering.max_iterations} iterations used)
            </span>
          )}
        </h3>
        <p className="text-xs text-muted-foreground mb-3">
          The agent will make another attempt incorporating your guidance.
        </p>
        <textarea
          className="w-full border rounded-md px-3 py-2 text-sm min-h-[80px] resize-y focus:outline-none focus:ring-1 focus:ring-ring bg-background"
          placeholder="e.g. Use slog instead of log. Also update the test helpers that wrap the logger..."
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
        />
        <Button
          className="mt-2"
          onClick={() => steerMutation.mutate()}
          disabled={busy || !prompt.trim()}
        >
          {steerMutation.isPending ? 'Sending...' : 'Send Steering Prompt'}
        </Button>
      </div>

      {/* History */}
      {!!steering?.history?.length && (
        <>
          <Separator />
          <div>
            <h3 className="text-sm font-medium mb-3">Steering history</h3>
            <div className="space-y-2">
              {steering.history.map((item, i) => (
                <div key={i} className="text-sm border rounded-md px-3 py-2 bg-muted/30">
                  <span className="text-xs text-muted-foreground">Iteration {item.iteration}: </span>
                  {item.prompt}
                </div>
              ))}
            </div>
          </div>
        </>
      )}
    </div>
  )
}
```

**Step 2: Verify build, commit**

```bash
cd web && npm run build && cd ..
git add web/src/components/SteeringPanel.tsx
git commit -m "feat(web): implement SteeringPanel with approve/reject/steer actions"
```

---

### Task 14: VerifierLogs + GroupProgress components

**Files:**
- Modify: `web/src/components/VerifierLogs.tsx`
- Modify: `web/src/components/GroupProgress.tsx`

**Step 1: Implement `VerifierLogs.tsx`**

```tsx
import { useQuery } from '@tanstack/react-query'
import { api } from '@/api/client'

export function VerifierLogs({ workflowId }: { workflowId: string }) {
  const { data, isLoading } = useQuery({
    queryKey: ['logs', workflowId],
    queryFn: () => api.getLogs(workflowId),
    refetchInterval: 15_000,
  })

  if (isLoading) return <p className="text-sm text-muted-foreground">Loading...</p>
  if (!data?.logs?.length) return <p className="text-sm text-muted-foreground">No verifier output yet.</p>

  return (
    <div className="space-y-4 max-w-3xl">
      {data.logs.map((log, i) => (
        <div key={i} className="border rounded-lg overflow-hidden">
          <div className={`flex items-center gap-2 px-4 py-2 text-sm font-medium ${log.success ? 'bg-green-50' : 'bg-red-50'}`}>
            <span className={log.success ? 'text-green-700' : 'text-red-700'}>
              {log.success ? '✓' : '✗'} {log.verifier}
            </span>
            <span className="text-xs text-muted-foreground ml-auto">exit {log.exit_code}</span>
          </div>
          {(log.stdout || log.stderr) && (
            <pre className="text-xs p-4 bg-muted/30 overflow-auto max-h-64 font-mono whitespace-pre-wrap">
              {log.stdout}{log.stderr}
            </pre>
          )}
        </div>
      ))}
    </div>
  )
}
```

**Step 2: Implement `GroupProgress.tsx`**

```tsx
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { api } from '@/api/client'
import { Button } from '@/components/ui/button'

export function GroupProgress({ workflowId }: { workflowId: string }) {
  const qc = useQueryClient()
  const { data: progress, isLoading } = useQuery({
    queryKey: ['progress', workflowId],
    queryFn: () => api.getProgress(workflowId),
    refetchInterval: 3000,
  })
  const continueMutation = useMutation({
    mutationFn: (skipRemaining: boolean) => api.continue(workflowId, skipRemaining),
    onSuccess: () => qc.invalidateQueries({ queryKey: ['progress', workflowId] }),
  })

  if (isLoading) return <p className="text-sm text-muted-foreground">Loading...</p>
  if (!progress || progress.total_groups === 0)
    return <p className="text-sm text-muted-foreground">This task doesn't use grouped execution.</p>

  const { total_groups, completed_groups, failed_groups, failure_percent, is_paused, paused_reason, failed_group_names } = progress

  return (
    <div className="max-w-lg space-y-4">
      <div className="flex gap-6 text-sm">
        <span><span className="text-muted-foreground">Total:</span> {total_groups}</span>
        <span><span className="text-muted-foreground">Done:</span> {completed_groups}</span>
        <span className={failed_groups > 0 ? 'text-red-600' : ''}>
          <span className="text-muted-foreground">Failed:</span> {failed_groups} ({failure_percent.toFixed(1)}%)
        </span>
      </div>

      <div className="w-full bg-muted rounded-full h-2">
        <div
          className="bg-foreground h-2 rounded-full transition-all"
          style={{ width: `${(completed_groups / total_groups) * 100}%` }}
        />
      </div>

      {is_paused && (
        <div className="border border-yellow-400 rounded-lg p-4 bg-yellow-50">
          <p className="text-sm font-medium text-yellow-800 mb-1">Execution paused</p>
          {paused_reason && <p className="text-xs text-yellow-700 mb-3">{paused_reason}</p>}
          <div className="flex gap-2">
            <Button size="sm" onClick={() => continueMutation.mutate(false)} disabled={continueMutation.isPending}>
              Continue
            </Button>
            <Button size="sm" variant="outline" onClick={() => continueMutation.mutate(true)} disabled={continueMutation.isPending}>
              Skip remaining
            </Button>
          </div>
        </div>
      )}

      {!!failed_group_names?.length && (
        <div>
          <p className="text-sm font-medium mb-1">Failed groups:</p>
          <ul className="text-sm text-red-600 list-disc list-inside">
            {failed_group_names.map((name) => <li key={name}>{name}</li>)}
          </ul>
        </div>
      )}
    </div>
  )
}
```

**Step 3: Verify build, commit**

```bash
cd web && npm run build && cd ..
git add web/src/components/VerifierLogs.tsx web/src/components/GroupProgress.tsx
git commit -m "feat(web): implement VerifierLogs and GroupProgress components"
```

---

## Phase C: Integration

### Task 15: Go embed + Makefile wiring

Wire the frontend build into `make build` and embed the built output in the Go binary.

**Files:**
- Create: `web/embed.go`
- Modify: `cmd/server/main.go`
- Modify: `internal/server/server.go` (update `buildStaticHandler`)
- Modify: `Makefile`

**Step 1: Create `web/embed.go`**

The embed directive must live in a `.go` file in the same directory as the assets. `web/embed.go` is adjacent to `web/dist/`, so the path `dist` is valid.

```go
// Package web provides the embedded web UI assets.
package web

import "embed"

//go:embed dist
var DistFS embed.FS
```

**Step 2: Implement `buildStaticHandler` in `internal/server/server.go`**

Replace the placeholder `buildStaticHandler` with:

```go
func (s *Server) buildStaticHandler() http.Handler {
	fileServer := http.FileServer(http.FS(s.staticFS))
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		path := r.URL.Path[1:] // strip leading /
		if path == "" {
			path = "index.html"
		}
		if _, err := s.staticFS.Open(path); err != nil {
			// SPA fallback: unknown paths serve index.html
			r.URL.Path = "/"
		}
		fileServer.ServeHTTP(w, r)
	})
}
```

**Step 3: Update `cmd/server/main.go` to load the embedded FS**

```go
package main

import (
	"fmt"
	"io/fs"
	"log"
	"net/http"
	"os"

	flclient "github.com/tinkerloft/fleetlift/internal/client"
	"github.com/tinkerloft/fleetlift/internal/server"
	flweb "github.com/tinkerloft/fleetlift/web"
)

func main() {
	c, err := flclient.NewClient()
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to connect to Temporal: %v\n", err)
		os.Exit(1)
	}
	defer c.Close()

	webFS, err := fs.Sub(flweb.DistFS, "dist")
	if err != nil {
		log.Fatalf("failed to prepare static files: %v", err)
	}

	addr := os.Getenv("FLEETLIFT_SERVER_ADDR")
	if addr == "" {
		addr = ":8080"
	}

	s := server.New(c, webFS)
	log.Printf("Fleetlift server listening on %s", addr)
	if err := http.ListenAndServe(addr, s); err != nil {
		log.Fatalf("server error: %v", err)
	}
}
```

**Step 4: Check the existing Makefile**

```bash
head -30 Makefile
```

**Step 5: Add frontend targets to Makefile**

Find the existing `build` target and prepend `build-web` to it. Also add standalone targets. Use real tabs (not spaces) for recipe lines:

```makefile
.PHONY: build-web dev-web

build-web:
	cd web && npm install && npm run build

dev-web:
	cd web && npm run dev
```

Change the `build` target's dependencies to include `build-web`:
```makefile
build: build-web
	go build ./...
```

**Step 6: Run the full build**

```bash
make build
```
Expected: frontend builds to `web/dist/`, then `go build ./...` compiles with embedded files.

**Step 7: Run all tests**

```bash
go test ./...
```
Expected: all PASS

**Step 8: Commit**

```bash
git add web/embed.go cmd/server/main.go internal/server/server.go Makefile
git commit -m "feat: wire frontend build into Makefile and embed in Go binary"
```

---

### Task 16: Update IMPLEMENTATION_PLAN.md

Mark Phase 9.5 complete and add Phase 9.5 to the summary table.

**Files:**
- Modify: `docs/plans/IMPLEMENTATION_PLAN.md`

**Step 1: Update the last-updated line** (top of file):

Change: `> **Last Updated**: 2026-02-15 (Phase 6b Kubernetes Provider complete)`
To:     `> **Last Updated**: 2026-02-18 (Phase 9.5 Web UI complete)`

**Step 2: Update the Phase 9.3-9.6 summary row**

Change the single combined row:
```
| 9.3-9.6 | **Advanced Features** | Scheduled tasks, cost tracking, web UI, report storage | ⬜ Not started |
```
To four separate rows:
```
| 9.3 | **Scheduled tasks** | Temporal cron-style recurring tasks | ⬜ Not started |
| 9.4 | **Cost tracking** | API token + compute attribution | ⬜ Not started |
| 9.5 | **Web UI** | Inbox, diff review, approval/steering dashboard | ✅ Complete |
| 9.6 | **Report storage** | S3/GCS backend for large-scale discovery | ⬜ Not started |
```

**Step 3: Mark Phase 9.5 complete in the Phase 9 section** — add `- COMPLETE` to the "9.5 Web UI" subsection heading and tick all its checkboxes.

**Step 4: Commit**

```bash
git add docs/plans/IMPLEMENTATION_PLAN.md
git commit -m "docs: mark Phase 9.5 Web UI as complete"
```

---

## Quick Reference

| Command | Purpose |
|---------|---------|
| `make build-web` | Build frontend only |
| `make build` | Build frontend + Go binaries |
| `make dev-web` | Run Vite dev server (proxies `/api` to `:8080`) |
| `go run ./cmd/server` | Run API server (with embedded frontend) |
| `go test ./internal/server/...` | Run server tests |
| `TEMPORAL_ADDRESS=localhost:7233 go run ./cmd/server` | Run against local Temporal |
| `FLEETLIFT_SERVER_ADDR=:9090 go run ./cmd/server` | Custom port |
